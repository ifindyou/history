---
title: "符号的意义"
---

------

以下是一个神经病的臆想，这个神经病按照时间顺序学过汉语，英语，日语，c，c++，es3，es5，lisp，node,clojure，es6,但是都没有学会，最后疯掉了。他的短期目标是在公司里写只有自己看得懂别人却挑不出来毛病的代码来寻求一点安全感，顺便打发无聊的时间。他最喜欢做的事情，就是把一件事情反复的说。他最害怕的，就是别人看出他是一个神经病。

当科尔森脑海中不断复现那些符号的时候，他总是忍不住在墙上刻下来，但他不知道这些符号的意义，活着只会把他逼疯掉，他只能不断的去追寻。最终，他找到了。而Tahiti里的其他人，却死掉了。

### 符号存在的原因是因为它所隐喻的意义,而人的存在原因就是寻找属于他自己的符号以及这些符号的意义。

#### 计算机语言是一堆符号的排列组合。

一台计算机，它只认识0和1，以不可想象的速度做着0和1的运算，但表现在人眼前的却是一个光怪陆离的世界，有光影，有色彩，有运动，甚至还能模拟人类的情感认知。真的不能更加神奇了，它们只是0和1而已。人和机器的关系，就是人按照语言的规则编码自己的想法，而机器按照语言的规则来翻译这些符号成为一系列0和1而已。

#### 符号是计算机语言中最重要的一个概念。程序不过是一堆值的运算而已，而它之所以比计算器更加高明，因为它为这些值找到了一种符号，一种隐喻值的符号。在它眼里连运算规则都是一种值，可以被映射的事物。我们用值来隐喻物理世界的各种事物以及他们之间的动态关系，而符号隐喻了这些值。

计算器只认识数字这种值，以及简单的计算规则。但是计算机认识的更多，有数字，字符串，对象，数组，函数，数字还分整形和浮点，但它们仍然只是值而已。计算机不仅认识更多的值，还能自定义指定的运算规则（函数）来运算这些值，而不仅仅是加减乘除或者其他数学运算。更加奇妙的时，计算机可以自己运算出新的运算规则，这个概念叫闭包。

当我在repl里输入值，得到的是值本身。当我们用一种符号指代一个值，然后再输入这个符号，得到的也是值本身，我们输入一个纯值表达式，得到的还是一个值，当我们输入一个符号表达式，得到的还是一个值。程序不过是给我们求值而已，而且是立刻求出值。这个时间有多短？可能仅仅只是几纳秒，或者更小的时间片段。

#### 在一个世界里，只能存在一个同名符号，但不同的世界可以拥有同名符号而不至于引起混乱。
#### 一个世界包含一个世界，这种关系是一种树形的，它们形成了世界树。当一个值存在于一个世界，也就存在于所有的后代世界，除非后代世界用同名符号中断了这种传递。这就是作用域，符号的一个边界约束。

我们在所有需要值的地方都引用这个符号，而不是用值本身参与求值，是有好处的。当我们需要一百个0，参与运算的时候，如果我们硬编码了0，我们将会占用一百个内存空间来存储这些0，并且在变化无常的世界里，也许0有一天需要变成1，那么我们要手动改变一百次，无论对于机器和人来说，都是一种负担。这个时候符号的出现就是必然，我们用一个符号来绑定这个值，并且在表达式里引用符号而不是值本身，我们只需要两个空间和一次修改而已。这真的是一件非常爽的事情。

##### 另外一种情景下，我们可能不仅仅是想复用值，还想复用一段表达式，当我们写下了一个表达式时，repl 读它，求值它，输出它，等着下一个循环。我们除了得到值外，便失去了这个表达式，它不再复现，除非我们再输入一个相同的表达式。想到将用一个符号来隐喻值，我们也可以用一个符号来隐喻一段表达式，这个符号代表了一段不会被求值的表达式，当我们需要求值时，只需要用求值符号来组合它就行了。

##### 另一种情景，我们不仅想惰性这段表达式，还想惰性出现在这个表达式里的符号，只想在我们需要它执行的时候再执行，这个时候便有了参数，当我们想求值的时候，只需要表达式和参数和求值符号的一个组合而已。

这就是我所理解的变量，函数，参数的起源。
##### 你以为符号绑定的一定是值吗？或许它绑定的是另一个符号，因为符号在复制时会发生克隆，如果一个非常大的个体被克隆的话，那么内存很快会消耗掉，当我们用符号的符号来绑定它时，克隆的只不过是一个符号而已。

v8为我们做的就是找到这些符号的值，，然后在我们指定的时间上按照我们定义的运算规则来求值这些符号和表达式而已。程序是时间线上的状态集。

#### 视线再次转移到函数身上。函数本质也是值，一个惰性的表达式和一组惰性的符号。当v8要执行这个函数时，它是怎么做的？

创建一个世界，找到所有符号的值，然后参与运算，返回一个值给上级程序，然后销毁掉这个世界。

v8是如何找到这些值？

传参，词法作用域，this，原型，就这四个手段了，没有其它任何手段了。
也就是说词法作用域，this，参数，原型这四个概念不过是我们用来编码自己的意图，程序解码我们意图的一个规则分支而已。

当理解了四个概念的意图之后，就可以自由的使用它们了。

##### 计算机世界里的树，和真实的树不一样，它是倒置的，根在上，叶子在下。
##### 我将每个作用域叫做一个世界。所有的作用域组成了一颗树。每个节点都可以看做是一颗子树的根，这种同构的结构是计算机和数学世界里最迷人的概念了。
所有的值和符号都是依赖于某个世界而产生的。先有世界，才会有符号以及值，然后这个世界会复用上层的所有的符号和值，但会被同名符号给打断。一个世界里的符号和值有两类，一类是这个世界生成的，另一类就是捕获了世界树上的。换句话说，一个符号和值，不仅仅存在于它所诞生的世界，还存在于所有这个世界繁衍出的后代世界树上，除非这棵树的某个世界创造了一个同名符号，才终止这种传递。
当一个世界里的符号绑定了一个值后，这种绑定关系便被这个世界里的后代世界树捕获，但是世界却捕获不了上层树里的符号和同级树里的符号。两颗世界树里里的人，永远意识不到对方的存在一样，哪怕值相等。这点和人很像，人永远感受和想象不到另一个世界里的真实的或者虚幻的一切，永远。

在程序世界里有一个闭包的概念，或许给绝望的世界加入了一点希望。一个世界树里的值可以越狱到其它世界树并且绑定到其它世界树里的符号，而因为这种越狱，这个世界树不会在程序执行完毕后消失，而是永远存在，直到外部世界解除了这种绑定关系，当一个死寂的世界只为一种联系而存在的时候，这种联系便有了意义。如果这种唯一的联系被切断了，符合和世界存在的意义便消失了。而回收这些值和世界的凶手，就是v8世界里的gc。

##### this的规则更简单，this只是一种绑定关系而已，那么它会绑定什么值呢，完全取决于写代码的人的意图。但都遵守一种语义，this就是这个子程的拥有者。
什么是拥有者？
1.当一个裸的符号被执行时，无关乎它生存的世界，拥有者都是是root，在浏览器里是window，在node里是global。这是js之父的想法。

但是后来的标准委员会成员们并不这么想，他们在严格模式下，定义了一个函数如果在局部世界里求值，那么它的拥有者不存在。undefined的这个值就是隐喻不存在的事物。
2.当使用点符号引用这个函数符号时，这个函数的拥有者就是.前面的那个符号所隐喻的值。
3.我们可以把任何函数装入闭包里，然后让这个闭包通过apply和call来指定函数的this，这样无论如何我们怎么调用这个闭包，无论是裸的调用还是.符号调用，闭包的this会改变，而被闭包捕获的函数都将固定了this，第三个方法并不违背1和2号规则。这三个规则都遵循一条规则this==拥有者。

es6里也出来了很多类似3号规则的语法糖，但那只是一个假象而已，我懒得说了。

#####形参和实参。

实参符号将值传递给形参符号，就是一个复制的过程。但是对于简单值和复合值有一点点的不同。
简单值的符号绑定的是值本身，而复合值的符号绑定的是值的符号。如果学习c的指针，就会懂了。js也不过是一种语法糖而已。

#####所有的值都拥有这个__proto__符号，这个符号指向了另一个值，一个值将拥有--proto--链上所有值的一切。new运算符只不过是隐式的创建了一个空对象并隐式的绑定了--proto--的值而已。使用它将建立一个复杂的复用网络，和作用域树一样复杂的复用网络。




